import {
  BlogMarkdownLayout,
  BlogImage,
  BlogCalloutBox,
} from "../../../../components/BlogMarkdownLayout";
import { StackAnimation } from "../../../../components/StackAnimation";
import { MatchingAnimation } from "../../../../components/MatchingAnimation";

import releaseCover from "./stylish-mustache.png";
import syntaxHighlighter from "./vscode.png";

export const meta = {
  title: "Stylish mustaches",
  date: "2026-02-25",
  author: "Peter Stenger",
  tags: ["Technical", "Development"],
};

# PrairieLearn finally has stylish mustaches!

No, we didn't all grow mustaches overnight. But all of our `question.html` and `*.mustache` files
authored in PrairieLearn's custom portmanteau of Markdown and HTML are now formatted and linted.

This is possible because of a new grammar, formatter, linter, and LSP (Language Server Protocol) server that
I have written, [`treesitter-htmlmustache`](https://github.com/reteps/treesitter-htmlmustache) ( not the most creative name :] ).

In July 2025, I did the original research and development on this grammar, and then in January / February 2026, I
was able to add a syntax highlighter, LSP, formatter, and linter based on this grammar.

Here is a screenshot of the syntax highlighter in action:

<BlogImage src={syntaxHighlighter} alt="Syntax highlighter in VSCode" />

## The grammar

The grammar is a custom [tree-sitter](https://tree-sitter.github.io/tree-sitter/) grammar based on [tree-sitter-html](https://github.com/tree-sitter/tree-sitter-html).

I originally looked into implementation of this as a modification of the tree-sitter-htmldjango grammar, but the parsing (especially the tag matching) from that grammar was not as good as I would have liked. More on this later.

Originally, I looked into [handlebars], which is a variant of mustache that was taken over by the ember team.
They already supported essentially our syntax, but I eventually abandoned the effort after discussions with the ember team,
as it seemed that they wanted to wait for the typescript rewrite before making any changes to their parser.

Next, I looked into how editors like VSCode and Emacs do syntax highlighting. VSCode still uses TextMate grammars, which is an interesting artifact of the original implementation. However, the problem with syntax highlighting based grammars
is that you can't get a parse tree from them easily (at least, I couldn't find a way). This means that you can never use them for formatting or linting. At the suggestion of [@shorden](), I looked into doing this with a tree-sitter grammar.
Initial results seemed promising, with tooling like topiary built for turning a grammar into a formatter easily.

I also looked into volarjs, but I ultimately went with tree-sitter since it had a more mature ecosystem.

https://github.com/topiary/topiary + https://github.com/topiary/topiary/issues/1036
https://volarjs.dev/
https://github.com/atom/language-mustache
https://github.com/microsoft/vscode/issues/50140

https://github.com/glimmerjs/glimmer-vm/pull/1281
https://github.com/handlebars-lang/handlebars-parser/issues/5
https://github.com/handlebars-lang/handlebars-parser/pull/23

https://tree-sitter.github.io/tree-sitter/creating-parsers/3-writing-the-grammar.html

### Difficulties

Mustache and HTML are two independent nesting systems that can cross each other's boundaries. The scanner needs to be able to handle this so that they are aware of each other -- that is,
for tag matching, the scanner needs to know context about the other nesting system. I originally maintained a list of associated tags on each mustache tag, which was a pain, since the custom data structures must be manually serialized and deserialized out of memory.

The key insight I made while developing the grammar was to maintain a count of the number of HTML tags that have been opened inside the current mustache section. This allows the scanner to know exactly which HTML tags are associated with the current mustache section, and which are not.

### Implementation

The scanner (src/scanner.c:44-47) maintains two parallel stacks:

```
  typedef struct {
      Array(Tag) tags;              // HTML tag stack
      Array(MustacheTag) mustache_tags;  // Mustache section stack
  } Scanner;
```

Then, on each MustacheTag, we maintain a count of the number of HTML tags that have been opened inside the current mustache section.

```
  typedef struct {
    String tag_name;
    unsigned html_tag_stack_size;  // <-- this is the key
  } MustacheTag;
```

Then, when we close a mustache section, we check if the HTML stack is taller than the count on the current MustacheTag. If it is, we pop an HTML tag and emit an implicit end tag. tree-sitter will hit this condition repeatedly until the
 HTML stack is the same height as the count on the current MustacheTag. 
This lets us (1) emit multiple symbols for a single closing tag, 
and (2) helps us maintain the correct parse tree.

```
  MustacheTag *current_mustache_tag = array_back(&scanner->mustache_tags);
  if (scanner->tags.size > current_mustache_tag->html_tag_stack_size) {
      // HTML tags were opened inside this section that haven't been closed!
      pop_html_tag(scanner);
      lexer->result_symbol = MUSTACHE_END_TAG_HTML_IMPLICIT_END_TAG;
      return true;
  }
  ```


<StackAnimation />

The snapshot number creates a fence — the Mustache close tag knows exactly which HTML tags belong to it (those above the fence) and implicitly closes them. In line 1, `<b>` is force-closed when `{{/bold}}` arrives (the scanner sees the HTML stack is taller than the snapshot). In line 2, `</b>` appears with nothing on the HTML stack — the parser records it as an erroneous end tag.

## The linter

Now that the parser can handle these patterns, how does the linter verify correctness? The key challenge is that Mustache sections are conditionally rendered — a template might be valid when a section is truthy but broken when it's falsy (or vice versa). The linter uses a **balance-checking algorithm** that:

1. **Extracts** fork points from the parse tree — each section that contains HTML events creates a fork with truthy (T) and falsy (F) branches
2. **Merges** adjacent forks for the same section name — this avoids redundant analysis
3. **Balance-checks** each fork's branches independently, skipping forks where both branches are balanced
4. **Enumerates** the remaining paths (2^n for n unbalanced sections) and flattens events to find errors

Click through the steps below to see this algorithm in action:

<MatchingAnimation />

## Other features

I also added a formatter, that was inspired by Prettier's architecture. This kept the formatter implementation easy to iterate on. 

https://github.com/prettier/prettier/blob/main/commands.md
https://prettier.io/docs/technical-details

The IR for that looks like:


```
  ┌─────────────┬───────────────────────────────────────┬───────────────────────────────────────────────────────────────────────────┐
  │    Node     │                Fields                 │                                Description                                │
  ├─────────────┼───────────────────────────────────────┼───────────────────────────────────────────────────────────────────────────┤
  │ string      │ (literal)                             │ Raw text output                                                           │
  ├─────────────┼───────────────────────────────────────┼───────────────────────────────────────────────────────────────────────────┤
  │ Concat      │ parts: Doc[]                          │ Sequence of docs                                                          │
  ├─────────────┼───────────────────────────────────────┼───────────────────────────────────────────────────────────────────────────┤
  │ Indent      │ contents: Doc                         │ Indent contents by one level                                              │
  ├─────────────┼───────────────────────────────────────┼───────────────────────────────────────────────────────────────────────────┤
  │ Hardline    │ —                                     │ Always breaks to a new line                                               │
  ├─────────────┼───────────────────────────────────────┼───────────────────────────────────────────────────────────────────────────┤
  │ Softline    │ —                                     │ Breaks only if the enclosing group breaks, otherwise nothing              │
  ├─────────────┼───────────────────────────────────────┼───────────────────────────────────────────────────────────────────────────┤
  │ Line        │ —                                     │ Breaks if group breaks, otherwise a space                                 │
  ├─────────────┼───────────────────────────────────────┼───────────────────────────────────────────────────────────────────────────┤
  │ Group       │ contents, break?, id?                 │ Try to print flat; break if it doesn't fit. id lets IfBreak reference it  │
  ├─────────────┼───────────────────────────────────────┼───────────────────────────────────────────────────────────────────────────┤
  │ Fill        │ parts: Doc[]                          │ Inline content that wraps when needed (parts alternate content/separator) │
  ├─────────────┼───────────────────────────────────────┼───────────────────────────────────────────────────────────────────────────┤
  │ BreakParent │ —                                     │ Forces the enclosing group to break                                       │
  ├─────────────┼───────────────────────────────────────┼───────────────────────────────────────────────────────────────────────────┤
  │ IfBreak     │ breakContents, flatContents, groupId? │ Conditional output based on whether a group broke                         │
  └─────────────┴───────────────────────────────────────┴───────────────────────────────────────────────────────────────────────────┘
```

I also added support for custom lint rules, which is useful for things like enforcing a maximum line length, or checking for unused variables. For example, we can check for hidden inputs inside `{{#items}}` sections:

```
    {
      "id": "no-hidden-inputs-in-list",
      "selector": "#items > input[type=hidden]",
      "message": "Hidden inputs inside {{#items}} sections are usually a mistake",
    },
```

<BlogCalloutBox variant="info">
  You can check out the full implementation in the [treesitter-htmlmustache](https://github.com/reteps/treesitter-htmlmustache) repository.
  If you have questions or feedback, open an issue on the repository!
</BlogCalloutBox>

export default ({ children }) => (
  <BlogMarkdownLayout meta={meta}>{children}</BlogMarkdownLayout>
);
